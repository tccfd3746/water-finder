<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ“± åœ°å€æœå°‹èˆ‡å³æ™‚å®šä½ - 300 å…¬å°ºæ¶ˆé˜²æ “</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha204-Jj0p59h61Hw84D76gX+rPzK52t/u3aFw10d0y7lU3Z55W6aD05k2F5k49E2b3I0tB"
        crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <style>
        /* è¨­å®šåœ°åœ–å®¹å™¨çš„å¤§å° */
        #map {
            height: 100vh;
            width: 100%;
        }
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha204-GjJ7w+28zTfNlB/j6hO55/W27T2tU62/P0bW8d0K3pYw7V8w5f9aH5f5A3B9c7E7"
        crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <script>
        // ============== æ‡‰ç”¨ç¨‹å¼æ ¸å¿ƒè¨­å®š ==============

        const SEARCH_RADIUS_METERS = 300; // æ ¸å¿ƒåƒæ•¸ï¼šæœå°‹åŠå¾‘ (å…¬å°º)
        let watchId; // ğŸŒŸ æ–°å¢ï¼šç”¨æ–¼å„²å­˜ watchPosition çš„ IDï¼Œä»¥ä¾¿åœæ­¢è¿½è¹¤
        let isWatching = true; // ğŸŒŸ æ–°å¢ï¼šè¿½è¹¤ç‹€æ…‹æ¨™è¨˜
        let hydrantData = []; // å„²å­˜ GeoJSON è¼‰å…¥çš„è³‡æ–™

        // ============== è®Šæ•¸èˆ‡åœ°åœ–åˆå§‹åŒ– ==============

        const map = L.map('map').setView([24.1500, 120.6800], 13);

        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Â© OpenStreetMap è²¢ç»è€…'
        }).addTo(map);

        let userMarker;

        // ============== è·é›¢è¨ˆç®—å‡½å¼ (Haversine å…¬å¼) ==============
        
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // åœ°çƒåŠå¾‘ (å…¬é‡Œ)
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c; // è·é›¢ (å…¬é‡Œ)
            return distance;
        }


        // ============== å®šä½èˆ‡æ¨™è¨˜é‚è¼¯ (é€šç”¨å‡½å¼) ==============

        // é€™å€‹å‡½å¼ç¾åœ¨å¯ä»¥è¢«å³æ™‚å®šä½æˆ–åœ°å€æœå°‹æˆåŠŸå¾Œå‘¼å«
        function findAndMarkHydrants(lat, lng, sourceName = "æ‚¨çš„ç›®å‰ä½ç½®") {
            const userLatLng = [lat, lng];
            
            // ç§»é™¤èˆŠçš„æ¨™è¨˜å’Œåœ“åœˆ
            map.eachLayer(layer => {
                if (layer !== userMarker && layer !== map.tileLayer) {
                    map.removeLayer(layer);
                }
            });
            if (userMarker) {
                map.removeLayer(userMarker);
            }
            
            // 1. æ¨™è¨˜æœå°‹æˆ–å®šä½çš„ä¸­å¿ƒé»
            userMarker = L.marker(userLatLng).addTo(map)
                .bindPopup(`<b>${sourceName}</b>`).openPopup();
            
            // 2. è¨ˆç®—æ‰€æœ‰æ¶ˆé˜²æ “è·é›¢ä¸¦éæ¿¾å‡ºåœ¨ 300 å…¬å°ºå…§çš„ç›®æ¨™
            const nearbyHydrants = hydrantData.map(hydrant => {
                const distanceKm = getDistance(lat, lng, hydrant.lat, hydrant.lng);
                const distanceMeters = distanceKm * 1000;
                
                return {
                    ...hydrant,
                    distance: distanceMeters 
                };
            }).filter(hydrant => hydrant.distance <= SEARCH_RADIUS_METERS); 

            // 3. å°ç¯©é¸å¾Œçš„ç›®æ¨™é€²è¡Œæ’åº (ç”±è¿‘åˆ°é )
            nearbyHydrants.sort((a, b) => a.distance - b.distance); 

            // 4. è¨­å®šåœ°åœ–è¦–è§’å’Œç¸®æ”¾
            map.setView(userLatLng, 16); 

            // 5. ç¹ªè£½ 300 å…¬å°ºåœ“åœˆ
            L.circle(userLatLng, { 
                radius: SEARCH_RADIUS_METERS,
                color: 'blue', 
                fillColor: '#90b4e0', 
                fillOpacity: 0.2,
                weight: 2
            }).addTo(map);

            // 6. æ¨™è¨˜æ¶ˆé˜²æ “
            const fireHydrantIcon = L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            });

            nearbyHydrants.forEach((hydrant, index) => {
                const distanceInMeters = hydrant.distance.toFixed(0); 
                
                // å»ºç«‹ Google åœ°åœ–å°èˆªé€£çµ
                const googleMapsUrl = `http://googleusercontent.com/maps.google.com/5{hydrant.lat},${hydrant.lng}`;
                
                L.marker([hydrant.lat, hydrant.lng], { icon: fireHydrantIcon }).addTo(map)
                    .bindPopup(`
                        <b>æ¶ˆé˜²æ “ #${index + 1}: ${hydrant.name}</b><br>
                        è·é›¢: **${distanceInMeters} å…¬å°º**<br>
                        <hr style="margin: 5px 0;">
                        <a href="${googleMapsUrl}" target="_blank" 
                           style="display: block; padding: 5px; background-color: #4285F4; color: white; text-align: center; text-decoration: none; border-radius: 3px; font-weight: bold;">
                           ğŸš— é–‹å§‹å°èˆª (Google Maps)
                        </a>
                    `);
            });
            
            // 7. é¡¯ç¤ºçµæœæç¤º
            const resultCount = nearbyHydrants.length;
            const message = resultCount > 0 
                ? `åœ¨ ${SEARCH_RADIUS_METERS} å…¬å°ºå…§æ‰¾åˆ° ${resultCount} å€‹æ¶ˆé˜²æ “ã€‚`
                : `åœ¨ ${SEARCH_RADIUS_METERS} å…¬å°ºå…§æ²’æœ‰æ‰¾åˆ°ä»»ä½•æ¶ˆé˜²æ “ã€‚`;

            // å¦‚æœæ˜¯å³æ™‚å®šä½è¿½è¹¤ï¼Œå‰‡ä¸å¼·åˆ¶æ‰“é–‹ Popupï¼Œé¿å…æŒçºŒå¹²æ“¾
            if (sourceName !== "æ‚¨çš„ç›®å‰ä½ç½® (å³æ™‚)") {
                 L.popup()
                    .setLatLng(userLatLng)
                    .setContent(`<b>æœå°‹çµæœï¼š</b>${message}`)
                    .openOn(map);
            }
        }

        // ğŸŒŸ è™•ç†å³æ™‚å®šä½æˆåŠŸçš„å‡½å¼
        function onLocationFound(pos) {
            // åªæœ‰åœ¨è¿½è¹¤ç‹€æ…‹ä¸‹æ‰æ›´æ–°ä½ç½®
            if (isWatching) {
                findAndMarkHydrants(pos.coords.latitude, pos.coords.longitude, "æ‚¨çš„ç›®å‰ä½ç½® (å³æ™‚)");
            }
        }

        // è™•ç†å®šä½å¤±æ•—çš„å‡½å¼ (ä¿æŒä¸è®Š)
        function onLocationError(error) {
            let errorMessage = "ç„¡æ³•å–å¾—æ‚¨çš„ä½ç½®ã€‚è«‹æª¢æŸ¥æ‚¨çš„å®šä½è¨­å®šæ˜¯å¦é–‹å•Ÿã€‚";
            
            if (error.code === error.PERMISSION_DENIED) {
                errorMessage = "æ‚¨æ‹’çµ•äº†å®šä½è«‹æ±‚ã€‚è«‹å…è¨±ç€è¦½å™¨ä½¿ç”¨æ‚¨çš„ä½ç½®ã€‚";
                stopWatching(); // æ‹’çµ•æ™‚åœæ­¢è¿½è¹¤
            }
            
            L.popup()
                .setLatLng(map.getCenter())
                .setContent(`å®šä½å¤±æ•—ï¼š${errorMessage}`)
                .openOn(map);
        }

        // ğŸŒŸ æ–°å¢ï¼šåœæ­¢å³æ™‚å®šä½è¿½è¹¤
        function stopWatching() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                isWatching = false;
                console.log("å·²åœæ­¢å³æ™‚å®šä½è¿½è¹¤ã€‚");
                
                // æç¤ºä½¿ç”¨è€…å·²åœæ­¢
                L.popup()
                    .setLatLng(map.getCenter())
                    .setContent("å·²åœæ­¢å³æ™‚å®šä½è¿½è¹¤ã€‚æ‚¨ç¾åœ¨å¯ä»¥ä½¿ç”¨åœ°å€æœå°‹åŠŸèƒ½ã€‚")
                    .openOn(map);
            }
        }
        
        // ğŸŒŸ æ–°å¢ï¼šå•Ÿå‹•å³æ™‚å®šä½è¿½è¹¤
        function startWatching() {
            if ("geolocation" in navigator) {
                isWatching = true;
                watchId = navigator.geolocation.watchPosition(
                    onLocationFound, 
                    onLocationError, 
                    { 
                        enableHighAccuracy: true, 
                        timeout: 10000,          
                        maximumAge: 0            
                    }
                );
                console.log("å·²å•Ÿå‹•å³æ™‚å®šä½è¿½è¹¤ã€‚");
            } else {
                alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´åœ°ç†ä½ç½®åŠŸèƒ½ã€‚");
            }
        }

        // ============== æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•é‚è¼¯ (GeoJSON è³‡æ–™è¼‰å…¥) ==============

        async function loadHydrantData() {
            try {
                const response = await fetch('hydrants.geojson'); 
                
                if (!response.ok) {
                    throw new Error(`HTTP éŒ¯èª¤! ç‹€æ…‹ç¢¼: ${response.status}ã€‚è«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦å­˜åœ¨ä¸¦é‹è¡Œæ–¼ä¼ºæœå™¨ã€‚`);
                }
                
                const geoJsonData = await response.json();
                
                return geoJsonData.features
                    .filter(feature => feature.geometry && feature.geometry.type === 'Point')
                    .map(feature => {
                        const coords = feature.geometry.coordinates;
                        return {
                            lat: coords[1], 
                            lng: coords[0],
                            name: feature.properties.name || feature.properties.Name || feature.properties.title || 'æœªçŸ¥æ¶ˆé˜²æ “'
                        };
                    });
            } catch (error) {
                console.error("è¼‰å…¥æ¶ˆé˜²æ “è³‡æ–™å¤±æ•—:", error);
                
                L.popup()
                    .setLatLng(map.getCenter())
                    .setContent(`è¼‰å…¥ GeoJSON å¤±æ•—ï¼š${error.message}`)
                    .openOn(map);
                return [];
            }
        }

        // æ‡‰ç”¨ç¨‹å¼ä¸»è¦å•Ÿå‹•é»
        async function initApp() {
            // 1. è¼‰å…¥è³‡æ–™ä¸¦å­˜å…¥å…¨åŸŸè®Šæ•¸
            hydrantData = await loadHydrantData();
            
            // 2. ğŸŒŸ æ–°å¢ï¼šåŠ å…¥åœ°å€æœå°‹æ§åˆ¶é …
            L.Control.geocoder({
                placeholder: 'è¼¸å…¥åœ°å€æˆ–åœ°æ¨™...',
                defaultMarkGeocode: false // é¿å…è‡ªå‹•æ¨™è¨˜ï¼Œç”±æˆ‘å€‘è‡ªå·±è™•ç†
            }).on('markgeocode', function(e) {
                // åœæ­¢å³æ™‚è¿½è¹¤ï¼Œå› ç‚ºä½¿ç”¨è€…æ­£åœ¨æ‰‹å‹•æœå°‹ä½ç½®
                stopWatching(); 
                
                const center = e.geocode.center;
                const name = e.geocode.name;
                
                // ä½¿ç”¨æœå°‹åˆ°çš„ç¶“ç·¯åº¦å‘¼å«å‡½å¼
                findAndMarkHydrants(center.lat, center.lng, `æœå°‹åœ°é»: ${name}`);
            }).addTo(map);

            // 3. ğŸŒŸ æ–°å¢ï¼šåŠ å…¥åœæ­¢è¿½è¹¤æŒ‰éˆ• (è‡ªè¨‚ Leaflet æ§åˆ¶é …)
            const StopControl = L.Control.extend({
                options: {
                    position: 'topright'
                },
                onAdd: function (map) {
                    const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                    container.style.backgroundColor = 'white';
                    container.style.padding = '10px';
                    container.style.cursor = 'pointer';
                    container.innerHTML = 'ğŸ›‘ åœæ­¢å³æ™‚å®šä½';

                    container.onclick = function(){
                        stopWatching();
                        // æ”¹è®ŠæŒ‰éˆ•é¡¯ç¤ºï¼Œä¾‹å¦‚è®Šæˆã€Œé–‹å§‹è¿½è¹¤ã€
                        container.innerHTML = 'ğŸŸ¢ é–‹å§‹å³æ™‚å®šä½';
                        container.onclick = function(){
                            startWatching();
                            container.innerHTML = 'ğŸ›‘ åœæ­¢å³æ™‚å®šä½';
                            container.onclick = arguments.callee; // æ¢å¾©åœæ­¢åŠŸèƒ½
                        }
                    }
                    return container;
                }
            });
            map.addControl(new StopControl());

            // 4. ğŸŒŸ å•Ÿå‹•å³æ™‚å®šä½è¿½è¹¤
            startWatching();
        }

        initApp();
    </script>

</body>
</html>
