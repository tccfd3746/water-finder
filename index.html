<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ“± 300 å…¬å°ºå…§æ¶ˆé˜²æ “æœå°‹</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha204-Jj0p59h61Hw84D76gX+rPzK52t/u3aFw10d0y7lU3Z55W6aD05k2F5k49E2b3I0tB"
        crossorigin=""/>
    <style>
        /* è¨­å®šåœ°åœ–å®¹å™¨çš„å¤§å° */
        #map {
            height: 100vh;
            width: 100%;
        }
        /* è®“ç¶²é åœ¨æ‰‹æ©Ÿä¸Šä¿æŒå…¨è¢å¹•é¡¯ç¤º */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha204-GjJ7w+28zTfNlB/j6hO55/W27T2tU62/P0bW8d0K3pYw7V8w5f9aH5f5A3B9c7E7"
        crossorigin=""></script>

    <script>
        // ============== æ‡‰ç”¨ç¨‹å¼æ ¸å¿ƒè¨­å®š ==============

        // ğŸ¯ æ ¸å¿ƒåƒæ•¸ï¼šè¨­å®šæœå°‹çš„åŠå¾‘ï¼Œå–®ä½æ˜¯å…¬å°º (Meters)
        const SEARCH_RADIUS_METERS = 300; 

        // ============== è®Šæ•¸èˆ‡åœ°åœ–åˆå§‹åŒ– ==============

        const map = L.map('map').setView([24.1500, 120.6800], 13); // é è¨­è¦–è§’

        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Â© OpenStreetMap è²¢ç»è€…'
        }).addTo(map);

        let userMarker;

        // ============== è·é›¢è¨ˆç®—å‡½å¼ (Haversine å…¬å¼) ==============
        
        // ç”¨æ–¼è¨ˆç®—åœ°çƒä¸Šå…©é»é–“æº–ç¢ºè·é›¢çš„æ•¸å­¸å…¬å¼ (çµæœç‚ºå…¬é‡Œ)ã€‚
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // åœ°çƒåŠå¾‘ (å…¬é‡Œ)
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c; // è·é›¢ (å…¬é‡Œ)
            return distance;
        }


        // ============== å®šä½èˆ‡æ¨™è¨˜é‚è¼¯ (300 å…¬å°ºç¯„åœç¯©é¸) ==============

        function onLocationFound(pos, fireHydrantData) {
            const userLat = pos.coords.latitude;
            const userLng = pos.coords.longitude;
            const userLatLng = [userLat, userLng];
            
            if (userMarker) {
                map.removeLayer(userMarker);
            }
            
            // 1. æ¨™è¨˜ä½¿ç”¨è€…ä½ç½® (è—è‰²åœ–æ¨™)
            userMarker = L.marker(userLatLng).addTo(map)
                .bindPopup("<b>æ‚¨çš„ç›®å‰ä½ç½®</b>").openPopup();
            
            // 2. ç§»é™¤èˆŠçš„æ¶ˆé˜²æ “æ¨™è¨˜
            map.eachLayer(layer => {
                if (layer instanceof L.Marker && layer !== userMarker) {
                    map.removeLayer(layer);
                }
            });

            // 3. è¨ˆç®—æ‰€æœ‰æ¶ˆé˜²æ “è·é›¢ä¸¦éæ¿¾å‡ºåœ¨ 300 å…¬å°ºå…§çš„ç›®æ¨™
            const nearbyHydrants = fireHydrantData.map(hydrant => {
                const distanceKm = getDistance(userLat, userLng, hydrant.lat, hydrant.lng);
                const distanceMeters = distanceKm * 1000; // è½‰æ›ç‚ºå…¬å°º
                
                return {
                    ...hydrant,
                    distance: distanceMeters 
                };
            // ğŸŒŸ æ ¸å¿ƒéæ¿¾é‚è¼¯ï¼šåªä¿ç•™è·é›¢å°æ–¼ç­‰æ–¼ 300 å…¬å°ºçš„ç›®æ¨™
            }).filter(hydrant => hydrant.distance <= SEARCH_RADIUS_METERS); 

            // 4. å°ç¯©é¸å¾Œçš„ç›®æ¨™é€²è¡Œæ’åº (ç”±è¿‘åˆ°é ï¼Œæ–¹ä¾¿ä½¿ç”¨è€…æŸ¥çœ‹)
            nearbyHydrants.sort((a, b) => a.distance - b.distance); 

            // 5. è¨­å®šåœ°åœ–è¦–è§’å’Œç¸®æ”¾ (ç¸®æ”¾ç´šåˆ¥ 16 é©åˆè§€å¯Ÿ 300-500 å…¬å°ºç¯„åœ)
            map.setView(userLatLng, 16); 
            
            // 6. æ¨™è¨˜ 300 å…¬å°ºå…§çš„æ‰€æœ‰æ¶ˆé˜²æ “ (ç´…è‰²åœ–æ¨™)
            const fireHydrantIcon = L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            });

            nearbyHydrants.forEach((hydrant, index) => {
                const distanceInMeters = hydrant.distance.toFixed(0); 
                
                // å»ºç«‹ Google åœ°åœ–å°èˆªé€£çµ
                const googleMapsUrl = `http://googleusercontent.com/maps.google.com/4{hydrant.lat},${hydrant.lng}`;
                
                L.marker([hydrant.lat, hydrant.lng], { icon: fireHydrantIcon }).addTo(map)
                    .bindPopup(`
                        <b>æ¶ˆé˜²æ “ #${index + 1}: ${hydrant.name}</b><br>
                        è·é›¢: **${distanceInMeters} å…¬å°º**<br>
                        <hr style="margin: 5px 0;">
                        <a href="${googleMapsUrl}" target="_blank" 
                           style="display: block; padding: 5px; background-color: #4285F4; color: white; text-align: center; text-decoration: none; border-radius: 3px; font-weight: bold;">
                           ğŸš— é–‹å§‹å°èˆª (Google Maps)
                        </a>
                    `);
            });
            
            // 7. é¡¯ç¤ºçµæœæç¤º
            const resultCount = nearbyHydrants.length;
            const message = resultCount > 0 
                ? `åœ¨ ${SEARCH_RADIUS_METERS} å…¬å°ºå…§æ‰¾åˆ° ${resultCount} å€‹æ¶ˆé˜²æ “ã€‚`
                : `åœ¨ ${SEARCH_RADIUS_METERS} å…¬å°ºå…§æ²’æœ‰æ‰¾åˆ°ä»»ä½•æ¶ˆé˜²æ “ã€‚`;

            // ç‚ºäº†æ–¹ä¾¿ä½¿ç”¨è€…è¦–è¦ºåŒ– 300 å…¬å°ºç¯„åœï¼Œæˆ‘å€‘å¯ä»¥åœ¨ä½¿ç”¨è€…ä½ç½®å‘¨åœç¹ªè£½ä¸€å€‹åœ“åœˆ
            L.circle(userLatLng, { 
                radius: SEARCH_RADIUS_METERS, // åŠå¾‘ 300 å…¬å°º
                color: 'blue', 
                fillColor: '#90b4e0', 
                fillOpacity: 0.2,
                weight: 2
            }).addTo(map); 

            L.popup()
                .setLatLng(userLatLng)
                .setContent(`<b>æœå°‹çµæœï¼š</b>${message}`)
                .openOn(map);

            if (fireHydrantData.length === 0) {
                 L.popup()
                    .setLatLng(userLatLng)
                    .setContent("è­¦å‘Šï¼šGeoJSON è³‡æ–™è¼‰å…¥æˆåŠŸä½†ç‚ºç©ºã€‚è«‹æª¢æŸ¥ hydrants.geojson å…§å®¹ã€‚")
                    .openOn(map);
            }
        }

        // è™•ç†å®šä½å¤±æ•—çš„å‡½å¼ (ä¿æŒä¸è®Š)
        function onLocationError(error) {
            let errorMessage = "ç„¡æ³•å–å¾—æ‚¨çš„ä½ç½®ã€‚è«‹æª¢æŸ¥æ‚¨çš„å®šä½è¨­å®šæ˜¯å¦é–‹å•Ÿã€‚";
            
            if (error.code === error.PERMISSION_DENIED) {
                errorMessage = "æ‚¨æ‹’çµ•äº†å®šä½è«‹æ±‚ã€‚è«‹å…è¨±ç€è¦½å™¨ä½¿ç”¨æ‚¨çš„ä½ç½®ã€‚";
            }
            
            L.popup()
                .setLatLng(map.getCenter())
                .setContent(`å®šä½å¤±æ•—ï¼š${errorMessage}`)
                .openOn(map);
        }


        // ============== æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•é‚è¼¯ (GeoJSON è³‡æ–™è¼‰å…¥) ==============

        async function loadHydrantData() {
            try {
                const response = await fetch('hydrants.geojson'); 
                
                if (!response.ok) {
                    throw new Error(`HTTP éŒ¯èª¤! ç‹€æ…‹ç¢¼: ${response.status}ã€‚è«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦å­˜åœ¨ä¸¦é‹è¡Œæ–¼ä¼ºæœå™¨ã€‚`);
                }
                
                const geoJsonData = await response.json();
                
                const processedData = geoJsonData.features
                    .filter(feature => feature.geometry && feature.geometry.type === 'Point')
                    .map(feature => {
                        const coords = feature.geometry.coordinates;
                        return {
                            lat: coords[1], 
                            lng: coords[0],
                            name: feature.properties.name || feature.properties.Name || feature.properties.title || 'æœªçŸ¥æ¶ˆé˜²æ “'
                        };
                    });
                    
                return processedData;
                
            } catch (error) {
                console.error("è¼‰å…¥æ¶ˆé˜²æ “è³‡æ–™å¤±æ•—:", error);
                
                L.popup()
                    .setLatLng(map.getCenter())
                    .setContent(`è¼‰å…¥ GeoJSON å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆåç¨±å’Œä¼ºæœå™¨è¨­å®šï¼š${error.message}`)
                    .openOn(map);
                return [];
            }
        }

        async function initApp() {
            const hydrantData = await loadHydrantData();
            
            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => onLocationFound(pos, hydrantData), 
                    onLocationError, 
                    { 
                        enableHighAccuracy: true, 
                        timeout: 10000,          
                        maximumAge: 0            
                    }
                );
            } else {
                L.popup()
                    .setLatLng(map.getCenter())
                    .setContent("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´åœ°ç†ä½ç½®åŠŸèƒ½ï¼Œç„¡æ³•é€²è¡Œå®šä½ã€‚")
                    .openOn(map);
            }
        }

        initApp();
    </script>

</body>
</html>
